"""
     set_subdomain(cells::Array{Int,2},
                   points::Array{Float64,2},
                   epart::Array{Int64,1},
                   idom::Int)

  
Returns helper data structures for non-overlaping domain decomposition using the mesh 
partition defined by epart and npart. 
  
Input:

 `cells::Array{Int,2}`, `size(cells) = (3, n_el)`,
  nodes of each element.

 `points::Array{Float64,2}`, `size(cells) = (2, nnode)`,
  (x,y)-coordinates of all mesh nodes.

 `epart::Array{Int,1}`, `size(epart) = (mesh.n_cell,)`,
  host subdomain of each element.

 `idom::Int`,
  subdomain index.

Output:

 `inds_l2g::Array{Int,1}`,
  conversion table from local to global node indices in subdomain `idom`.

 `inds_g2l::Dict{Int,Int}`,
  conversion table from global to global node indices in subdomain `idom`.

 `elems::Array{Int,1}`,
  indices of elements in subdomain `idom`.

 `center::Array{Float64,1}`, `size(center) = (2,)`,
  approximate (x,y)-coordinates of the center of subdomain `idom`.

"""
function set_subdomain(cells::Array{Int,2},
                       points::Array{Float64,2},
                       epart::Array{Int64,1},
                       idom::Int)

  _, nel = size(cells) # Number of elements
  inds_l2g = Int[]  # Conversion table from local to global indices of the
                    # nodes of the idom-th subdomain
  inds_g2l = Dict{Int, Int}() # Conversion table from global to local indices of the 
                              # nodes of the idom-th subdomain
  elems = Int[] # Elements contained in subdomain
  center = zeros(2) # Center of subdomain
  energy = 0.

  iel_cell = zeros(Int, 3)
  for iel in 1:nel

    # Element is in subdomain idom
    if epart[iel] == idom
      
      # Add element
      push!(elems, iel)

      # Set-up local indices and conversion tables for nodes in element
      for node in cells[:, iel]
        if !haskey(inds_g2l, node)
          push!(inds_l2g, node)
          inds_g2l[node] = length(inds_l2g)
        end
      end
    end
  end

  for inode in inds_l2g
    center[1] += points[1, inode]
    center[2] += points[2, inode]
  end
  center ./= length(inds_l2g)

  return inds_l2g, inds_g2l, elems, center
end


"""
     do_local_mass_covariance_assembly(cells::Array{Int,2},
                                       points::Array{Float64,2},
                                       inds_l2g::Array{Int,1},
                                       inds_g2l::Dict{Int,Int},
                                       elems::Array{Int,1},
                                       cov::Function)

Assembles local Galerkin kernel operator of a subdomain generated by the
covariance function cov with 2D P1 finite elements with a given global
triangulation (cells, points).

Input:

 `cells::Array{Int,2}`, `size(cells) = (3, n_el)`,
  nodes of each element.

 `points::Array{Float64,2}`, `size(cells) = (2, nnode)`,
  (x,y)-coordinates of all mesh nodes.

 `inds_l2g::Array{Int,1}`,
  conversion table from non-dirichlet node indices of subdomain to global 
  mesh node indices.

 `inds_g2l::Dict{Int,Int}`,
  conversion table from global mesh node indices to non-dirichlet node 
  indices of subdomain.

 `cov::Function`, `cov(x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Float64`,
  covariance function.

Output:

 `C::Array{Float64,2}`, `size(C) = (inds_g2l.count, inds_g2l.count)`,
  array of local Galerkin formulation s.t. `C[i, j] = ∫_Ω Φ_i(P) ∫_{Ω'} cov(P, P') Φ_j(P') dΩ' dΩ`.

"""
function do_local_mass_covariance_assembly(cells::Array{Int,2},
                                           points::Array{Float64,2},
                                           inds_l2g::Array{Int,1},
                                           inds_g2l::Dict{Int,Int},
                                           elems::Array{Int,1},
                                           cov::Function)

  nel = length(elems) # Number of elements in subdomain
  nnode = inds_g2l.count # Number of nodes of subdomain
  R = zeros(nnode, nnode) # R[i, j] ≈ ∑_e ∫_{Ω'_e} Φ_i(P') cov(P', P_j) dΩ'
  C = zeros(nnode, nnode) # C[i, j] ≈ ∫_Ω Φ_i(P) ∫_{Ω'} cov(P, P') Φ_j(P') dΩ' dΩ.
  x, y = zeros(3), zeros(3) # (x, y) coordinates of element vertices
  Δx, Δy = zeros(3), zeros(3), zeros(3) # Used to store terms of shoelace formula
  Area = zeros(nel) # Used to store element areas
  
  # Loop over mesh nodes
  for (jnode, node) in enumerate(inds_l2g)
    
    # Get coordinates of node
    xj = points[1, node]
    yj = points[2, node]
    
    # Loop over elements
    for (iel, el) in enumerate(elems)
      
      # Get (x, y) coordinates of each element vertex
      # and coefficient at the center of the element
      for r in 1:3
        rr = cells[r, el]
        x[r], y[r] = points[1, rr], points[2, rr]
      end
      
      # Terms of the shoelace formula for a triangle
      Δx[1] = x[3] - x[2]
      Δx[2] = x[1] - x[3]
      Δx[3] = x[2] - x[1]
      Δy[1] = y[2] - y[3]
      Δy[2] = y[3] - y[1]
      Δy[3] = y[1] - y[2]
      
      # Area of element
      Area_el = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.
      Area[iel] = Area_el
      
      # Add local contributions
      for r in 1:3
        s = r + 1 - floor(Int, (r + 1) / 3) * 3
        s == 0 ? s = 3 : nothing
        t = r + 2 - floor(Int, (r + 2) / 3) * 3
        t == 0 ? t = 3 : nothing
        inode = inds_g2l[cells[r, el]]
        R[inode, jnode] += (2 * cov(x[r], y[r], xj, yj) 
                              + cov(x[s], y[s], xj, yj) 
                              + cov(x[t], y[t], xj, yj)) * Area_el / 12
      end
    end
  end
  
  # Loop over mesh nodes
  for (inode, node) in enumerate(inds_l2g)
    
    # Loop over elements
    for (jel, el) in enumerate(elems)
      
      # Get area of element
      Area_el = Area[jel]
      
      # Add local contributions
      for r in 1:3
        s = r + 1 - floor(Int, (r + 1) / 3) * 3
        s == 0 ? s = 3 : nothing
        t = r + 2 - floor(Int, (r + 2) / 3) * 3
        t == 0 ? t = 3 : nothing
        jnode = inds_g2l[cells[r, el]]
        knode = inds_g2l[cells[s, el]]
        lnode = inds_g2l[cells[t, el]]
        C[inode, jnode] += (2 * R[inode, jnode] 
                              + R[inode, knode]  
                              + R[inode, lnode]) * Area_el / 12
      end
    end
  end
  
  return C
end


"""
     do_local_mass_assembly(cells::Array{Int,2},
                            points::Array{Float64,2}, 
                            inds_g2l::Dict{Int,Int}, 
                            elems::Array{Int,1})

Gets mass matrix of linear form using 2D P1 finite elements with a 
given triangulation (cells, points).

Input:

 `cells::Array{Int,2}`, `size(cells) = (3, n_el)`,
  nodes of each element.

 `points::Array{Float64,2}`, `size(cells) = (2, nnode)`,
  (x,y)-coordinates of all mesh nodes.

 `inds_g2l::Dic{Int,Int}`,
  conversion table from global mesh node indices to node indices of subdomain.

 `elems::Array{Int,1}`,
  elements of subdomain.

Output:

 `M::SparseMatrixCSC{Float64}`, `size(M) = (inds_g2l.count, inds_g2l.count)`,
  local mass matrix of subdomain s.t. `M[i, j] = ∫_Ω Φ_i(P) Φ_j(P) dΩ`.

"""
function do_local_mass_assembly(cells::Array{Int,2},
                                points::Array{Float64,2}, 
                                inds_g2l::Dict{Int,Int}, 
                                elems::Array{Int,1})

  nel = length(elems) # Number of elements in subdomain
  nnode = inds_g2l.count # Number of nodes of subdomain
  I, J, V = Int[], Int[], Float64[] # Indices (I, J) and data (V) for mass matrix
  x, y = zeros(3), zeros(3) # (x, y) coordinates of element vertices
  Δx, Δy = zeros(3), zeros(3), zeros(3) # Used to store terms of shoelace formula
  
  # Loop over elements
  for (iel, el) in enumerate(elems)
    
    # Get (x, y) coordinates of each element vertex
    # and coefficient at the center of the element
    for r in 1:3
      rnode = cells[r, el]
      x[r], y[r] = points[1, rnode], points[2, rnode]
    end
    
    # Terms of the shoelace formula for a triangle
    Δx[1] = x[3] - x[2]
    Δx[2] = x[1] - x[3]
    Δx[3] = x[2] - x[1]
    Δy[1] = y[2] - y[3]
    Δy[2] = y[3] - y[1]
    Δy[3] = y[1] - y[2]
    
    # Area of element
    Area = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.
    
    # Loop over vertices of element
    for i in 1:3
      inode = inds_g2l[cells[i, el]]

      # Loop over vertices of element
      for j in 1:3
        
        # Store local contribution
        if i == j
          Kij = Area / 6.
        else
          Kij = Area / 12.
        end
        jnode = inds_g2l[cells[j, el]]
        push!(I, inode)
        push!(J, jnode)
        push!(V, Kij)
      end
    end
  end
  
  # Assemble sparse mass matrix
  M = sparse(I, J, V)
  
  return M
end


"""
     do_global_mass_reduced_assembly(cells::Array{Int,2},
                                     points::Array{Float64,2},
                                     epart::Array{Int,1},
                                     inds_g2ld::Array{Dict{Int,Int},1},
                                     Φd::Array{Array{Float64,2},1})

Gets mass matrix of linear form using 2D P1 finite elements and basis functions
with local support over subdomains. Uses the triangulation (cells, points).
  
Input:

 `cells::Array{Int,2}`, `size(cells) = (3, n_el)`,
  nodes of each element.

 `points::Array{Float64,2}`, `size(cells) = (2, nnode)`,
  (x,y)-coordinates of all mesh nodes.

 `epart::Array{Int,1}`, `size(epart) = (n_el,)`,
  host subdomain of each element.

 `inds_g2ld`, `size(inds_g2ld) = (ndom,)`,
  conversion tables from global mesh node indices to non-dirichlet node 
  indices of subdomains.

 `Φd::Array{Array{Float64,2},1}`, `size(Φd) = (ndom,)`
  local dominant eigenfunctions of each subdomain.

Output:

 `M::SparseMatrixCSC{Float64}`,
  mass matrix of reduced problem.

"""
function do_global_mass_reduced_assembly(cells::Array{Int,2},
                                         points::Array{Float64,2},
                                         epart::Array{Int,1},
                                         inds_g2ld::Array{Dict{Int,Int},1},
                                         Φd::Array{Array{Float64,2},1})

  _, nel = size(cells) # Number of elements
  ndom = length(Φd) # Number of subdomains
  md = Int[] # Number of local modes for each subdomain
  I, J, V = Int[], Int[], Float64[] # Indices (I, J) and data (V) for mass matrix
  x, y = zeros(3), zeros(3) # (x, y) coordinates of element vertices
  Δx, Δy = zeros(3), zeros(3), zeros(3) # Used to store terms of shoelace formula

  # Get the number of local modes retained for each subdomain
  for idom in 1:ndom
    push!(md, size(Φd[idom])[2])
  end

  # Loop over elements
  for iel in 1:nel
      
    # Get (x, y) coordinates of each element vertex
    for r in 1:3
      rnode = cells[r, iel]
      x[r], y[r] = points[1, rnode], points[2, rnode]
    end
      
    # Terms of the shoelace formula for a triangle
    Δx[1] = x[3] - x[2]
    Δx[2] = x[1] - x[3]
    Δx[3] = x[2] - x[1]
    Δy[1] = y[2] - y[3]
    Δy[2] = y[3] - y[1]
    Δy[3] = y[1] - y[2]
      
    # Area of element
    Area = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.

    # Get host subdomain
    idom = epart[iel]

    # Loop over local modes of subdomain
    for α in 1:md[idom]
      idom == 1 ? ind_dα = α : ind_dα = sum(md[1:idom-1]) + α

      # Loop over local modes of subdomain 
      for β in α:md[idom]
        idom == 1 ? ind_dβ = β : ind_dβ = sum(md[1:idom-1]) + β

        # Loop over vertices of element
        value = 0.
        for i in 1:3
          inode = inds_g2ld[idom][cells[i, iel]]
          Φ_d_α_i = Φd[idom][inode, α]

          # Loop over vertices of element
          for j in 1:3
            jnode = inds_g2ld[idom][cells[j, iel]]
            Φ_d_β_j = Φd[idom][jnode, β]
            if i == j
              value += Φ_d_α_i * Φ_d_β_j * Area / 6
            else
              value += Φ_d_α_i * Φ_d_β_j * Area / 12
            end
          end
        end

        push!(I, ind_dα)
        push!(J, ind_dβ)
        push!(V, value)
        if β != α
          push!(I, ind_dβ)
          push!(J, ind_dα)
          push!(V, value)
        end
      end
    end
  end
    
  # Assemble sparse mass matrix
  M = sparse(I, J, V)
    
  return M
end


"""
     do_global_mass_covariance_reduced_assembly(cells::Array{Int,2},
                                                points::Array{Float64,2},
                                                elemsd::Array{Array{Int,1},1},
                                                inds_g2ld::Array{Dict{Int,Int},1},
                                                inds_l2gd::Array{Array{Int,1},1},
                                                Φd::Array{Array{Float64,2},1},
                                                centerd::Array{Array{Float64,1},1},
                                                cov::Function;
                                                forget=-1.)

Assembles Galerkin kernel operator generated by the covariance function
cov with 2D P1 finite elements with a given triangulation (cells, points).

Input:

 `cells::Array{Int,2}`, `size(cells) = (3, n_el)`,
  nodes of each element.

 `points::Array{Float64,2}`, `size(cells) = (2, nnode)`,
  (x,y)-coordinates of all mesh nodes.

 `inds_g2ld::Array{Dict{Int,Int},1}`, `size(inds_g2ld) = (ndom,)`
  conversion table from global mesh node indices to non-dirichlet node 
  indices of subdomain.

 `inds_l2gd::Array{Array{Int,1}}`, `size(inds_l2gd) = (ndom,)`
  conversion table from non-dirichlet node indices of subdomain to global 
  mesh node indices.
  
 `Φd::Array{Array{Float64,2},1}`, `size(Φd) = (ndom,)`
  local dominant eigenfunctions of each subdomain.
  
 `centerd::Array{Array{Float64,1},1}`, `size(centerd) = ndom`,
  (x,y)-coordinates of approximate center of each subdomain. 
  
 `cov::Function`, `cov(x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Float64`,
  covariance function.
  
 `forget=-1.`,
  threshold of covariance between centers used to ignore covariance contributions 
  between subdomains. By default, all contributions are considered. 

Output:

 `C::Array{Float64,2}`, 
  array of Galerkin formulation evaluated with eigenfunctions of local KL expansions.
 
"""
function do_global_mass_covariance_reduced_assembly(cells::Array{Int,2},
                                                    points::Array{Float64,2},
                                                    elemsd::Array{Array{Int,1},1},
                                                    inds_g2ld::Array{Dict{Int,Int},1},
                                                    inds_l2gd::Array{Array{Int,1},1},
                                                    Φd::Array{Array{Float64,2},1},
                                                    centerd::Array{Array{Float64,1},1},
                                                    cov::Function;
                                                    forget=-1.)

  _, nel = size(cells) # Number of elements
  _, nnode = size(points) # Number of nodes
  ndom = length(Φd) # Number of subdomains
  md = Int[] # Number of local modes for each subdomain
  x, y = zeros(3), zeros(3) # (x, y) coordinates of element vertices
  Δx, Δy = zeros(3), zeros(3), zeros(3) # Used to store terms of shoelace formula
  Area = zeros(nel) # Used to store element areas

  # Get the number of local modes retained for each subdomain
  for idom in 1:ndom
    push!(md, size(Φd[idom])[2])
  end

  # Global reduced mass covariance matrix
  md_sum = sum(md)
  K = zeros(md_sum, md_sum)
  
  # Loop over subdomains
  for idom in 1:ndom
    nnode_idom = inds_g2ld[idom].count

    # Loop over subdomains
    for jdom in idom:ndom

      # Check if subdomains are significantly correlated
      if cov(centerd[idom][1], centerd[idom][2], 
             centerd[jdom][1], centerd[jdom][2]) > forget
        
        nnode_jdom = inds_g2ld[jdom].count

        R = zeros(nnode_idom, nnode_jdom) # R[i, j] ≈ ∑_e ∫_{Ω'_e} Φ_i(P') cov(P', P_j) dΩ'
        C = zeros(nnode_idom, nnode_jdom) # C[i, j] ≈ ∫_Ω Φ_i(P) ∫_{Ω'} cov(P, P') Φ_j(P') dΩ' dΩ.

        # Loop over mesh nodes of the jdom-th subdomain 
        for (j, jnode) in enumerate(inds_l2gd[jdom])

          # Get coordinates of node
          xj = points[1, jnode]
          yj = points[2, jnode]
        
          # Loop over elements of the idom-th subdomain
          for (iel, el) in enumerate(elemsd[idom])
        
            # Get (x, y) coordinates of each element vertex
            for r in 1:3
              rnode = cells[r, el]
              x[r], y[r] = points[1, rnode], points[2, rnode]
            end
          
            # Terms of the shoelace formula for a triangle
            Δx[1] = x[3] - x[2]
            Δx[2] = x[1] - x[3]
            Δx[3] = x[2] - x[1]
            Δy[1] = y[2] - y[3]
            Δy[2] = y[3] - y[1]
            Δy[3] = y[1] - y[2]
          
            # Area of element
            Area_el = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.
          
            # Add local contributions
            for r in 1:3
              s = r + 1 - floor(Int, (r + 1) / 3) * 3
              s == 0 ? s = 3 : nothing
              t = r + 2 - floor(Int, (r + 2) / 3) * 3
              t == 0 ? t = 3 : nothing
              i = inds_g2ld[idom][cells[r, el]]
              R[i, j] += (2 * cov(x[r], y[r], xj, yj) 
                            + cov(x[s], y[s], xj, yj) 
                            + cov(x[t], y[t], xj, yj)) * Area_el / 12
            end
          end # for el
        end # for jnode
        
        # Loop over elements of the jdom-th subdomain
        for (jel, el) in enumerate(elemsd[jdom])
        
          # Get (x, y) coordinates of each element vertex
          for r in 1:3
            rnode = cells[r, el]
            x[r], y[r] = points[1, rnode], points[2, rnode]
          end
          
          # Terms of the shoelace formula for a triangle
          Δx[1] = x[3] - x[2]
          Δx[2] = x[1] - x[3]
          Δx[3] = x[2] - x[1]
          Δy[1] = y[2] - y[3]
          Δy[2] = y[3] - y[1]
          Δy[3] = y[1] - y[2]
          
          # Area of element
          Area_el = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.

          # Add local contributions
          for r in 1:3
            s = r + 1 - floor(Int, (r + 1) / 3) * 3
            s == 0 ? s = 3 : nothing
            t = r + 2 - floor(Int, (r + 2) / 3) * 3
            t == 0 ? t = 3 : nothing
            j = inds_g2ld[jdom][cells[r, el]]
            k = inds_g2ld[jdom][cells[s, el]]
            ℓ = inds_g2ld[jdom][cells[t, el]]

            # Loop over mesh nodes of the idom-th subdomain 
            for (i, inode) in enumerate(inds_l2gd[idom])
              C[i, j] += (2 * R[i, j] 
                            + R[i, k]  
                            + R[i, ℓ]) * Area_el / 12
            end
          end # for r
        end # for el

        # Loop over local modes of the idom-th subdomain
        for α in 1:md[idom]
          idom == 1 ? ind_α_idom = α : ind_α_idom = sum(md[1:idom-1]) + α 

          # Loop over local modes of the jdom-th subdomain
          for β in 1:md[jdom]
            jdom == 1 ? ind_β_jdom = β : ind_β_jdom = sum(md[1:jdom-1]) + β
          
            for j in 1:nnode_jdom
              Φ_j_β = Φd[jdom][j, β]
          
              for i in 1:nnode_idom
                K[ind_α_idom, ind_β_jdom] += Φd[idom][i, α] * C[i, j] * Φ_j_β
              end
            end
          
            idom == jdom ? nothing : K[ind_β_jdom, ind_α_idom] = K[ind_α_idom, ind_β_jdom]
          end # end β
        end # end α
      end # if subdomains are significantly correlated
    end # for jdom

    println("Done with idom = $idom.")
  end # for idom

  return K
end


"""
     solve_local_kl(cells::Array{Int,2},
                    points::Array{Float64,2},
                    epart::Array{Int,1},
                    cov::Function,
                    nev::Int,
                    idom::Int;
                    relative=.99)

Computes Karhunen Loeve (KL) decomposition of Gaussian process over a subdomain.
  
Input:            

 `cells::Array{Int,2}`, `size(cells) = (3, n_el)`,
  nodes of each element.

 `points::Array{Float64,2}`, `size(cells) = (2, nnode)`,
  (x,y)-coordinates of all mesh nodes.

 `epart::Array{Int,1}`, `size(epart) = (n_el,)`,
  host subdomain of each element.
                    
 `cov::Function`, `cov(x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Float64`,
  covariance function.
                    
 `nev::Int`,
  maximum number of wanted eigenvectors.
  
 `idom::Int`,
  subdomain index.
  
 `relative=.99`,
  energy threshold used to truncate the KL expansion.

Output:
                    
 `SubDomain`,
  contains eigenfunctions of local KL expansion.
                    
"""
function solve_local_kl(cells::Array{Int,2},
                        points::Array{Float64,2},
                        epart::Array{Int,1},
                        cov::Function,
                        nev::Int,
                        idom::Int;
                        relative=.99,
                        save_eigvals=false,
                        model="SExp",
                        sig2=1.,
                        L=.1,
                        tentative_nnode=20_000)

  ndom = maximum(epart) # Number of subdomains
  inds_l2g, inds_g2l, elems, center = set_subdomain(cells, points, epart, idom)
  
  # Assemble local generalized eigenvalue problem
  C = do_local_mass_covariance_assembly(cells, points, inds_l2g, 
                                        inds_g2l, elems, cov)
  M = do_local_mass_assembly(cells, points, inds_g2l, elems)
  
  # Solve local generalized eigenvalue problem
  λ, Φ = map(x -> real(x), Arpack.eigs(C, M, nev=nev))
  if save_eigvals
    root_fname = get_root_filename(model, sig2, L, tentative_nnode)
    ndom = maximum(epart)
    npzwrite("data/$root_fname.kl-local-eigvals-idom$idom-ndom$ndom.npz", λ)
  end

  # Integrate variance over subdomain
  x, y = zeros(3), zeros(3)
  Δx, Δy = zeros(3), zeros(3)
  Area = 0.
  for el in elems
    for r in 1:3
      rnode = cells[r, el]
      x[r], y[r] = points[1, rnode], points[2, rnode]
    end  
    Δx[1] = x[3] - x[2]
    Δx[2] = x[1] - x[3]
    Δx[3] = x[2] - x[1]
    Δy[1] = y[2] - y[3]
    Δy[2] = y[3] - y[1]
    Δy[3] = y[1] - y[2]   
    Area += (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.
  end
  energy_expected = relative * Area * cov(center[1], center[2],
                                          center[1], center[2])

  # Keep dominant eigenpairs with positive eigenvalues
  energy_achieved = 0.
  nvec = 0
  for i in 1:nev
    if λ[i] > 0 
      nvec += 1
      energy_achieved += λ[i]
    else
      break
    end
    energy_achieved >= energy_expected ? break : nothing
  end

  # Arpack 0.5.1 does not normalize the vectors properly
  for k in 1:nvec
    Φ[:, k] ./= sqrt(Φ[:, k]'M * Φ[:, k])
  end
  
  # Details about truncation
  str = "idom = $idom, $nvec/$nev vectors kept for "
  str *= @sprintf "%.5f" (energy_achieved / energy_expected * relative)
  println("$str relative energy")

  return SubDomain(inds_g2l,
                   inds_l2g,
                   elems,
                   Φ[:, 1:nvec],
                   center,
                   energy_expected / relative)
end


"""
     solve_global_reduced_kl(nnode::Int,
                             K::Array{Float64,2},
                             energy_expected::Float64,
                             elemsd::Array{Array{Int,1},1},
                             inds_l2gd::Array{Array{Int,1},1},
                             Φd::Array{Array{Float64,2},1};
                             relative=.99)

Solves eigenvalue problem previously assembled with local Karhunen Loeve (KL)
expansions of subdomains.

Input:

 `nnode::Int`,
  number of mesh nodes.

 `K::Array{Float64,2}`, `size(K) = (sum([size(Φ)[2] for Φ in Φd]), sum([size(Φ)[2] for Φ in Φd]))`,
  mass covariance matrix of reduced global problem.

 `energy_expected::Float64`,
  total energy wanted.

 `elemsd::Array{Array{Int,1},1}`, size(elemsd) = (ndom,)`,
  element indices of each subdomain.

 `inds_l2gd::Array{Array{Int,1},1}`, `size(inds_l2gd) = (ndom,)`,
  conversion tables from non-dirichlet node indices of subdomains to global 
  mesh node indices.

 `Φd::Array{Array{Float64,2},1}`, `size(Φd) = (ndom,)`
  local dominant eigenfunctions of each subdomain.

 `relative=.99`,
  relative energy threshold used to truncate the KL expansion.

Output:

 `Λ::Array{Float64,1}`, `size(Λ) = (nvec,)`,
  eigenvalues of KL expansion.

 `Ψ::Array{Float64,2}`, `size(Ψ) = (nnode, nvec)`
  eigenvectors of KL expansion.

"""
function solve_global_reduced_kl(nnode::Int,
                                 K::Array{Float64,2},
                                 energy_expected::Float64,
                                 elemsd::Array{Array{Int,1},1},
                                 inds_l2gd::Array{Array{Int,1},1},
                                 Φd::Array{Array{Float64,2},1};
                                 relative=.99)

  Ksym = LinearAlgebra.Symmetric(K)
  Λ, Φ = LinearAlgebra.eigen(Ksym)
  Λ, Φ = trim_and_order(Λ, Φ)
  energy_expected *= relative
  energy_achieved = 0.
  nvec = 0
  for λ_i in Λ
    energy_achieved += λ_i
    nvec += 1 
    energy_achieved >= energy_expected ? break : nothing
  end
  Ψ = project_on_mesh(nnode, Φ[:, 1:nvec], elemsd, inds_l2gd, Φd)

  # Details about truncation
  str = "$nvec/$(length(Λ)) vectors kept for "
  str *= @sprintf "%.5f" (energy_achieved / energy_expected * relative)
  println("$str relative energy")

  return Λ[1:nvec], Ψ
end


"""
     draw(mesh::TriangleMesh.TriMesh,
          Λ::Array{Float64,1},
          Φ::Array{Float64,2},
          Φd::Array{Array{Float64,2},1},
          inds_l2gd::Array{Array{Int,1},1})

Draws Gaussian process (GP) realization using eigenfunctions of local 
Karhunen Loeve (KL) expansions.

Input:

 `mesh::TriangleMesh.TriMesh`,
  triangular mesh.
 
 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  eigenvalues of KL expansion.
 
 `Φ::Array{Float64,2}`, `size(Φ) = (nnode, nmode)`,
  global eigenfunctions of reduced problem.
 
 `Φd::Array{Array{Float64,2},1}`, `size(Φd) = (ndom,)`
  local dominant eigenfunctions of each subdomain.

 `inds_l2gd::Array{Array{Int,1},1}`, `size(inds_l2gd) = (ndom,)`,
  conversion tables from non-dirichlet node indices of subdomains to global 
  mesh node indices.

Output:

 `ξ::Array{Float64,1}`, `size(ξ) = (nmode,)`,
  realization of latent random vector (rv) of KL expansion.

 `g::Array{Float64,1}`,
  GP realization.

"""
function draw(mesh::TriangleMesh.TriMesh,
              Λ::Array{Float64,1},
              Φ::Array{Float64,2},
              Φd::Array{Array{Float64,2},1},
              inds_l2gd::Array{Array{Int,1},1})

  nnode = mesh.n_point # Number of mesh nodes
  nmode = length(Λ) # Number of global modes
  ndom = length(Φd) # Number of subdomains
  md = Int[] # Number of local modes for each subdomain
  
  ξ = rand(Distributions.Normal(), nmode)
  g = zeros(nnode)
  cnt = zeros(Int, nnode)
  
  # Get the number of local modes retained for each subdomain
  for idom in 1:ndom
    push!(md, size(Φd[idom])[2])
  end
  
  for idom in 1:ndom
    for (i, inode) in enumerate(inds_l2gd[idom])
      cnt[inode] += 1
      for α in 1:md[idom]
        idom == 1 ? ind_α_idom = α : ind_α_idom = sum(md[1:idom-1]) + α
        for γ in 1:nmode
          g[inode] += sqrt(Λ[γ]) * ξ[γ] * Φ[ind_α_idom, γ] * Φd[idom][i, α]
        end
      end # for α
    end # for γ
  end # for idom
  g ./= cnt # should be done cleanly instead
  return ξ, g
end


"""
     project_on_mesh(nnodes::Int,
                     Φ::Array{Float64,2},
                     elemsd::Array{Array{Int,1},1},
                     inds_l2gd::Array{Array{Int,1},1},
                     Φd::Array{Array{Float64,2},1})

Projects discontinuous product of local and reduced global eigenfunctions
using P1 elements.

Input:

 `nnodes::Int`,
  number of mesh nodes.
 
 `Φ::Array{Float64,2}`, `size(Φ) = (nnode, nmode)`,
  global eigenfunctions of reduced problem.
 
 `elemsd::Array{Array{Int,1},1}`, size(elemsd) = (ndom,)`,
  element indices of each subdomain.
 
 `inds_l2gd::Array{Array{Int,1},1}`, `size(inds_l2gd) = (ndom,)`,
  conversion tables from non-dirichlet node indices of subdomains to global 
  mesh node indices.

 `Φd::Array{Array{Float64,2},1}`, `size(Φd) = (ndom,)`
  local dominant eigenfunctions of each subdomain.

Output:

 `Ψ::Array{Float64,2}`, `size(Ψ) = (nnode, nmode)`,
  eigenfunctions of KL expansion made contiguous.

"""
function project_on_mesh(nnodes::Int,
                         Φ::Array{Float64,2},
                         elemsd::Array{Array{Int,1},1},
                         inds_l2gd::Array{Array{Int,1},1},
                         Φd::Array{Array{Float64,2},1})

  ndom = length(elemsd) # Number of subdomains
  _, nmodes = size(Φ) # Number of reduced modes
  md = Int[] # Number of local modes in each subdomain
  Ψ = zeros(nnodes, nmodes) # Eigenfunction projection at the mesh nodes
  cnt = zeros(Int, nnodes) # Number of subdomains to which each node belongs

  # Get the number of local modes retained for each subdomain
  for idom in 1:ndom
    push!(md, size(Φd[idom])[2])
  end

  # Loop over reduced modes
  for imode in 1:nmodes

    # Loop over subdomains
    cnt .= 0
    for idom in 1:ndom

      # Loop over mesh nodes
      for (i, inode) in enumerate(inds_l2gd[idom])
        cnt[inode] += 1

        # Loop over local modes and add contributions
        for α in 1:md[idom]
          idom == 1 ? ind_α_idom = α : ind_α_idom = sum(md[1:idom-1]) + α
          Ψ[inode, imode] += Φ[ind_α_idom, imode] * Φd[idom][i, α]
        end 
      end # for inode
    end # for idom
    Ψ[:, imode] ./= cnt
  end # for imode

  return Ψ
end


"""
     draw(Λ::Array{Float64,1},
          Ψ::Array{Float64,2})

Draws a Gaussian process (GP) realization using a Karhunen Loeve (KL) expansion.

Input:

 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  eigenvalues of KL expansion.

 `Ψ::Array{Float64,2}`, `size(Ψ) = (nnode, nmode)`,
  eigenfunctions of KL expansion.

Output:

 `ξ::Array{Float64,1}`, `size(ξ) = (nmode,)`,
  realization of latent random vector (rv) of KL expansion.

 `g::Array{Float64,1}`, `size(g) = (nnode,)`,
  GP realization.

"""
function draw(Λ::Array{Float64,1},
              Ψ::Array{Float64,2})

  nnode, _ = size(Ψ) # Number of mesh nodes
  nmode = length(Λ) # Number of reduced modes

  ξ = rand(Distributions.Normal(), nmode)
  g = zeros(nnode)
  
  for α in 1:nmode
    g[:] += sqrt(Λ[α]) * ξ[α] * Ψ[:, α]
  end
  
  return ξ, g
end


"""
     draw!(Λ::Array{Float64,1},
           Ψ::Array{Float64,2},
           ξ::Array{Float64,1},
           g::Array{Float64,1})

Draws a Gaussian process (GP) realization in place of the vectors `ξ` and `g`
using a Karhunen Loeve (KL) expansion.

Input:

 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  eigenvalues of KL expansion.

 `Ψ::Array{Float64,2}`, `size(Ψ) = (nnode, nmode)`,
  eigenfunctions of KL expansion.

 `ξ::Array{Float64,1}`, `size(ξ) = (nmode,)`,
  realization of latent random vector (rv) of KL expansion.

 `g::Array{Float64,1})`, `size(Ψ) = (nnode,)`,
  GP realization.

"""
function draw!(Λ::Array{Float64,1},
               Ψ::Array{Float64,2},
               ξ::Array{Float64,1},
               g::Array{Float64,1})

  nnode, _ = size(Ψ) # Number of mesh nodes
  nmode = length(Λ) # Number of reduced modes

  ξ .= rand(Distributions.Normal(), nmode)
  g .= 0

  for α in 1:nmode
    c_α = sqrt(Λ[α]) * ξ[α]
    LinearAlgebra.BLAS.axpy!(c_α, Ψ[:, α], g)
  end

  return
end


"""
     trim_and_order(Λ::Array{Float64,1},
                    Φ::Array{Float64,2})

Returns strictly positive eigenvalues and eigenvectors sorted from
most to least dominant.

Input:

 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  non-sorted nor trimmed eigenvalues of KL expansion.

 `Φ::Array{Float64,2}`, `size(Φ) = (nnode, nmode)`,
  corresponing eigenfunctions.

Output:

 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  retained, sorted eigenvalues of KL expansion.

 `Φ::Array{Float64,2}`, `size(Φ) = (nnode, nmode)`,
  corresponing eigenfunctions.

"""
function trim_and_order(Λ::Array{Float64,1},
                        Φ::Array{Float64,2})
  
  neg_vals = sum([λ < 0 for λ in Λ])
  Λ = reverse(Λ[neg_vals+1:end])
  Φ = reverse(Φ[:, neg_vals+1:end], dims=2)
  return Λ, Φ
end


"""
     get_kl_coordinates(g::Array{Float64,1},
                        Λ::Array{Float64,1},
                        Φ::Array{Float64,2},
                        M::SparseMatrixCSC{Float64})

Recovers realization of latent vector `ξ` from a realization `g` of 
a Gaussian process (GP) with a given Karhunen Loeve decomposition.

Input:

 `g::Array{Float64,1}`, `size(g) = (nnode,)`,
  realization.

 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  eigenvalues of KL expansion.

 `Φ::Array{Float64,2}`, `size(Φ) = (nnode, nmode)`,
  corresponing eigenfunctions.

 `M::SparseMatrixCSC{Float64}`,
  mass matrix.

Output:

 `ξ::Array{Float64,1}`, `size(ξ) = (nmode,)`,
  realization of corresponding latent vector.

"""
function get_kl_coordinates(g::Array{Float64,1},
                            Λ::Array{Float64,1},
                            Φ::Array{Float64,2},
                            M::SparseMatrixCSC{Float64})

  nnode, nmode = size(Φ)
  g = M * g
  ξ = zeros(nmode)
  for (α, λ_α) in enumerate(Λ)
    sqrt_λ_α = sqrt(λ_α)
    for i in 1:nnode
      ξ[α] += Φ[i, α] * g[i] / sqrt_λ_α
    end
  end
  return ξ
end


"""
     set!(Λ::Array{Float64,1},
          Ψ::Array{Float64,2},
          ξ::Array{Float64,1},
          g::Array{Float64,1})

Assembles the coefficient field from a given latent vector.

Input:

 `Λ::Array{Float64,1}`, `size(Λ) = (nmode,)`,
  eigenvalues of KL expansion.

 `Ψ::Array{Float64,2}`, `size(Ψ) = (nnode, nmode)`,
  eigenfunctions of KL expansion.

 `ξ::Array{Float64,1}`, `size(ξ) = (nmode,)`,
  latent vector.

 `g::Array{Float64,1}`, `size(g) = (nnode,)`,
  coefficient field.

"""
function set!(Λ::Array{Float64,1},
              Ψ::Array{Float64,2},
              ξ::Array{Float64,1},
              g::Array{Float64,1})

  nnode, _ = size(Ψ) # Number of mesh nodes
  nmode = length(Λ) # Number of reduced modes

  g .= sqrt(Λ[1]) * ξ[1] * Ψ[:, 1]
  for α in 2:nmode
    g[:] += sqrt(Λ[α]) * ξ[α] * Ψ[:, α]
  end
  
  return g
end