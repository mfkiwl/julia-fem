using SparseArrays
import TriangleMesh


"""
set_subdomain(mesh::TriangleMesh.TriMesh, epart::Array{Int64,2}, npart::Array{Int64,2})
  
Returns helper data structures for non-overlaping domain decomposition using the mesh 
partition defined by epart and npart. 
  
Input:
  
mesh: Instance of TriangleMesh.TriMesh.

nel = mesh.n_cell
epart[iel, 1]: subdomain idom ∈ [1, ndom] to which element iel ∈ [1, nel] belongs.

nn = mesh.n_point
npart[inode, 1]: subdomain idom ∈ [1, ndom] to which node inode ∈ [1, nn] belongs.

Output:

elemd[idom][:]: 1D array of all the elements contained in subdomain idom ∈ [1, ndom].

node_Γ[:]: 1D array of global indices of the nodes at the interface of the mesh
           partition.


           
           ? IS node_Id necessary ?


node_Id[idom]: 1D array of global indices of the nodes strictly inside subdomain 
               idom ∈ [1, ndom].

ind_Id[idom]: Conversion table (i.e. dictionary) from global to local indices of 
              nodes strictly inside subdomain idom ∈ [1, ndom].

nn_Id[idom]: Number of nodes strictly inside subdomain idom ∈ [1, ndom].

is_on_Γ[inode]: True if node inode ∈ [1, nn] is on the interface of the mesh 
                partition, and false otherwise.
  
# Examples
```jldoctest
julia>
using TriangleMesh
using NPZ
using Fem

poly = polygon_unitSquare()
mesh = create_mesh(poly, info_str="my mesh", voronoi=true, delaunay=true, set_area_max=true)

ndom = 400
epart, npart = mesh_partition(mesh, ndom)
elemd, node_Γ, node_Id, ind_Id, nn_Id, is_on_Γ = set_subdomains(mesh, epart, npart)

```
"""
function set_subdomain(mesh::TriangleMesh.TriMesh, epart::Array{Int64,2}, idom::Int)
  nel = mesh.n_cell # Number of elements
  inds_l2g = Int[]  # Conversion table from local to global indices of the
                    # nodes of the idom-th subdomain
  inds_g2l = Dict{Int, Int}() # Conversion table from global to local indices of the 
                              # nodes of the idom-th subdomain
  elems = Int[] # Elements contained inside each subdomain

  iel_cell = zeros(Int, 3)
  for iel in 1:nel

    # Element is in subdomain idom
    if epart[iel] == idom
      
      # Add element
      push!(elems, iel)

      # Set-up local indices and conversion tables for nodes in element
      for node in mesh.cell[:, iel]
        if !haskey(inds_g2l, node)
          push!(inds_l2g, node)
          inds_g2l[node] = length(inds_l2g)
        end
      end
    end
  end

  return inds_l2g, inds_g2l, elems
end


"""
do_local_mass_covariance_assembly(cells, points, inds_l2g, inds_g2l, cov)

Assembles local Galerkin kernel operator of a subdomain generated by the
covariance function cov with 2D P1 finite elements with a given global
triangulation (cells, points).

Input:

cells[1:3, :]: Global node indices of each node of each element of the mesh
cells[1, el]: Global node index of 1st node of the el-th element
cells[2, el]: Global node index of 2nd node of the el-th element
cells[3, el]: Global node index of 3rd node of the el-th element

points[1:2, :]: Coordinates of all nodal points of the mesh
points[1, node]: x-coordinate of global node
points[2, node]: y-coordinate of global node

inds_l2g[inode]: Global node index of local inode

inds_g2l[node]: Local node index of global node

cov: function(x1::Float64, y1::Float64, x2::Float64, y2::Float64)::Float64 

Output:

C: Array of Galerkin formulation (nnode-by-nnode) where nnode = inds_g2l.count
   with components C_ij = ∫_Ω ϕ_i(P) ∫_{Ω'} cov(P, P') ϕ_j(P') dΩ' dΩ.

# Examples
```jldoctest
julia>
using TriangleMesh
using Fem

poly = polygon_Lshape()
mesh = create_mesh(poly, info_str="my mesh", voronoi=true, delaunay=true, set_area_max=true)

function cov(x1::Float64, y1::Float64, x2::Float64, y2::Float64)
  L = .1
  return exp(-((x1 - x2)^ 2 + (y1 - y2)^2) / L^2)
end

# Assembly for 11_894 DoFs
C = @time do_mass_covariance_assembly(mesh.cell, mesh.point, cov)

Maximum triangle area: .00005
 90.211575 seconds (243.67 k allocations: 2.121 GiB, 0.01% gc time)

```
"""
function do_local_mass_covariance_assembly(cells, points, inds_l2g, inds_g2l, elems, cov)
  nel = length(elems) # Number of elements in subdomain
  nnode = inds_g2l.count # Number of nodes of subdomain
  R = zeros(nnode, nnode) # R[i, j] ≈ ∑_e ∫_{Ω'_e} ϕ_i(P') cov(P', P_j) dΩ'
  C = zeros(nnode, nnode) # C[i, j] ≈ ∫_Ω ϕ_i(P) ∫_{Ω'} cov(P, P') ϕ_j(P') dΩ' dΩ.
  x, y = zeros(3), zeros(3) # (x, y) coordinates of element vertices
  Δx, Δy = zeros(3), zeros(3), zeros(3) # Used to store terms of shoelace formula
  Area = zeros(nel) # Used to store element areas
  
  # Loop over mesh nodes
  for (jnode, node) in enumerate(inds_l2g)
    
    # Get coordinates of node
    xj = points[1, node]
    yj = points[2, node]
    
    # Loop over elements
    for (iel, el) in enumerate(elems)
      
      # Get (x, y) coordinates of each element vertex
      # and coefficient at the center of the element
      for r in 1:3
        rr = cells[r, el]
        x[r], y[r] = points[1, rr], points[2, rr]
      end
      
      # Terms of the shoelace formula for a triangle
      Δx[1] = x[3] - x[2]
      Δx[2] = x[1] - x[3]
      Δx[3] = x[2] - x[1]
      Δy[1] = y[2] - y[3]
      Δy[2] = y[3] - y[1]
      Δy[3] = y[1] - y[2]
      
      # Area of element
      Area_el = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.
      Area[iel] = Area_el
      
      # Add local contributions
      for r in 1:3
        s = r + 1 - floor(Int, (r + 1) / 3) * 3
        s == 0 ? s = 3 : nothing
        t = r + 2 - floor(Int, (r + 2) / 3) * 3
        t == 0 ? t = 3 : nothing
        inode = inds_g2l[cells[r, el]]
        R[inode, jnode] += (2 * cov(x[r], y[r], xj, yj) 
                              + cov(x[s], y[s], xj, yj) 
                              + cov(x[t], y[t], xj, yj)) * Area_el / 12
      end
    end
  end
  
  # Loop over mesh nodes
  for (inode, node) in enumerate(inds_l2g)
    
    # Loop over elements
    for (jel, el) in enumerate(elems)
      
      # Get area of element
      Area_el = Area[jel]
      
      # Add local contributions
      for r in 1:3
        s = r + 1 - floor(Int, (r + 1) / 3) * 3
        s == 0 ? s = 3 : nothing
        t = r + 2 - floor(Int, (r + 2) / 3) * 3
        t == 0 ? t = 3 : nothing
        jnode = inds_g2l[cells[r, el]]
        knode = inds_g2l[cells[s, el]]
        lnode = inds_g2l[cells[t, el]]
        C[inode, jnode] += (2 * R[inode, jnode] 
                              + R[inode, knode]  
                              + R[inode, lnode]) * Area_el / 12
      end
    end
  end
  
  return C
end


"""
do_local_mass_assembly(cells, points)

Gets mass matrix of linear form using 2D P1 finite elements with a 
given triangulation (cells, points).

Input:

cells[1:3, 1:nel]: Global node indices of local nodes in each element
cells[1, iel]: Global node index of 1st node of element iel ∈ [1, nel]
cells[2, iel]: Global node index of 2nd node of element iel ∈ [1, nel]
cells[3, iel]: Global node index of 3rd node of element iel ∈ [1, nel]

points[1:2, 1:nnode]: Coordinates of all nodal points
points[1, inode]: x-coordinate of global node indexed inode ∈ [1, nnode]
points[2, inode]: y-coordinate of global node indexed inode ∈ [1, nnode]

Output:

M: Masss matrix formulation (nnode-by-nnode) with components 
   M_ij = ∫_Ω ϕ_i(P) ϕ_j(P) dΩ.

# Examples
```jldoctest
julia>
using TriangleMesh
using Fem

poly = polygon_Lshape()
mesh = create_mesh(poly, info_str="my mesh", voronoi=true, delaunay=true, set_area_max=true)

# Assembly for 11_894 DoFs
M = @time get_mass_matrix(mesh.cell, mesh.point)

Maximum triangle area: .00005
  0.337066 seconds (595.71 k allocations: 44.153 MiB)

```
"""
function do_local_mass_assembly(cells, points, inds_g2l, elems)
  nel = length(elems) # Number of elements in subdomain
  nnode = inds_g2l.count # Number of nodes of subdomain
  I, J, V = Int[], Int[], Float64[] # Indices (I, J) and data (V) for mass matrix
  x, y = zeros(3), zeros(3) # (x, y) coordinates of element vertices
  Δx, Δy = zeros(3), zeros(3), zeros(3) # Used to store terms of shoelace formula
  
  # Loop over elements
  for (iel, el) in enumerate(elems)
    
    # Get (x, y) coordinates of each element vertex
    # and coefficient at the center of the element
    for r in 1:3
      rnode = cells[r, el]
      x[r], y[r] = points[1, rnode], points[2, rnode]
    end
    
    # Terms of the shoelace formula for a triangle
    Δx[1] = x[3] - x[2]
    Δx[2] = x[1] - x[3]
    Δx[3] = x[2] - x[1]
    Δy[1] = y[2] - y[3]
    Δy[2] = y[3] - y[1]
    Δy[3] = y[1] - y[2]
    
    # Area of element
    Area = (Δx[3] * Δy[2] - Δx[2] * Δy[3]) / 2.
    
    # Loop over vertices of element
    for i in 1:3
      inode = inds_g2l[cells[i, el]]

      # Loop over vertices of element
      for j in 1:3
        
        # Store local contribution
        if i == j
          Kij = Area / 6.
        else
          Kij = Area / 12.
        end
        jnode = inds_g2l[cells[j, el]]
        push!(I, inode)
        push!(J, jnode)
        push!(V, Kij)
      end
    end
  end
  
  # Assemble sparse mass matrix
  M = sparse(I, J, V)
  
  return M
end